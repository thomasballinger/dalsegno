<html>
<head>
<title>live code reloading eventually</title>
<style type="text/css" media="screen">
    #editor { 
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 630px;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 630px;
      bottom: 0;
      right: 0;
    }
    .ace-monokai {
      opacity: .8;
    }
</style>
</head>
<body>

<div id="editor">(do
  (defn init-world
    (map (lambda i
           (list
             (list (randint 200) (randint 200))
             (list (randint -5 6) (randint -5 6))))
         (range 5)))
  (defn wrap-obj obj
    (list
      (list (% (first (first obj)) (width))
            (% (last (first obj)) (height)))
      (last obj)))
  (defn step-obj obj
    (list
      (list (+ (first (first obj)) (first (last obj)))
            (+ (last (first obj)) (last (last obj))))
      (last obj)))
  (defn render-obj obj (do
    (define radius 20)
    (drawCircle (first (first obj))
              (nth 1 (first obj))
              radius)))
  (defn game (do
    (define x 300)
    (define y 300)
    (define vx 1)
    (define vy 1)
    (display "game" "started")
    (define world (init-world))
    (defn nearby obj
      (do
        (< (dist x y (nth 0 (first obj)) (nth 1 (first obj))) 300)))
    (defn collide obj
        (< (dist x y (nth 0 (first obj)) (nth 1 (first obj))) (- (+ 20 50) 5)))
    (defn any-collide (reduce or (map collide world) 0))
    (defn to-render (filter nearby world))
    (define counter 0)
    (defn on-click (do
      (set! vx (+ vx (* (x_comp (towards x y (mousex) (mousey))) .5)))
      (set! vy (+ vy (* (y_comp (towards x y (mousex) (mousey))) .5)))))
    (defn main (do
      (color 250 250 220)
      (drawCircle x y 300)
      (color 30 100 200)
      (drawCircle x y 50)
      (color 230 100 200)
      (map render-obj (to-render))
      (set! world (map step-obj world))
      (set! world (map wrap-obj world))
      (if (clicked)
          (on-click))
      (set! x (+ x vx))
      (set! y (+ y vy))
      (if (> x (width)) (set! x 0))
      (if (> y (height)) (set! y 0))
      (if (< x 0) (set! x (width)))
      (if (< y 0) (set! y (height)))
      (render)
      (if (not (any-collide))
          (do 
            (set! counter (+ counter 1))
            (main))
          (do
            (drawText 100 100 "your" "score:" counter)))))
      (main)))
  (defn wait-for-unclick
    (if (clicked)
        (wait-for-unclick)))
  (defn wait-for-click
    (if (not (clicked))
        (wait-for-click)))
  (defn play-forever (do
    (game)
    (wait-for-unclick)
    (wait-for-click)
    (play-forever)))
  (play-forever))</div>

<script src="ace-builds/src-noconflict/ace.js" type="text/javascript" charset="utf-8"></script>
<script>
    var editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.getSession().setMode("ace/mode/scheme");
    var options = window.location.hash.substr(1);
    if (options.indexOf('vim') != -1){
      editor.setKeyboardHandler("ace/keyboard/vim");
    }
</script>

<canvas id="canvas" width="1" height="1"></canvas>
<script>
  var canvas = document.getElementById('canvas');
  canvas.width = window.innerWidth - 630;
  canvas.height = window.innerHeight;
</script>
    
<script src="deepcopy.js"></script>
<script src="parse.js"></script>
<script src="run.js"></script>
<script src="builtins.js"></script>
<script src="gamelib.js"></script>
<script src="stdlib.js"></script>
<script>
  var shouldReload = true; // on next tick, reload the program
  var currentlyRunning = false; // if not, change event needs to kick off runner
  var lib = new Gamelib('canvas');
  var gameMethods = lib.getFunctions();
  var env = new run.Environment([gameMethods, builtins, stdlib, {}]);
  var runner = new run.Runner({});
  runner.loadUserCode(editor.getValue(), env)
  var lastProgram = '';

  var speed = 220;

  var errback = function(e){ console.log(e); }

  var runABit = function(){
    var s = editor.getValue()
    if (shouldReload){
      shouldReload = false;
      if (parse.safelyParses(s), function(){}){
        runner.update(s);
        currentlyRunning = runner.runABit(speed, errback);
      } else {
        currentlyRunning = false;
        return;
      }
    }
    if (currentlyRunning) {
      currentlyRunning = runner.runABit(speed, errback);
      setTimeout(runABit, .001);
    }
  }
      
  var onChange = function(e){
    var s = editor.getValue();
    if (!parse.safelyParses(s)){
      lastProgram = '';
      currentlyRunning = false;
      return;
    }
    var newProgram = JSON.stringify(parse(editor.getValue()));
    if (newProgram === lastProgram){
      return;
    }
    lastProgram = newProgram;
    shouldReload = true;
    if (!currentlyRunning){
      currentlyRunning = true;
      runABit();
    }
  };

  editor.getSession().on('change', onChange);
  onChange()
</script>
</body>
</html>
